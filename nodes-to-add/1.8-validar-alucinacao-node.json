{
  "meta": {
    "instanceId": "mottivme-ai-factory"
  },
  "nodes": [
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// =====================================================\n// NÓ 1.8 - VALIDAR OUTPUT E CORRIGIR ALUCINAÇÕES\n// Detecta quando a IA \"inventou\" dados de outro cliente\n// =====================================================\n\n// Buscar dados do nó 1.6 (dados originais do cliente)\nlet dadosInput = {};\ntry {\n  const items16 = $('1.6 Preparar Dados').all();\n  if (items16 && items16.length > 0) {\n    dadosInput = items16[0].json;\n  }\n} catch (e) {\n  // Fallback: tentar buscar de outros nós possíveis\n  try {\n    const itemsPreparar = $('Preparar Dados').all();\n    if (itemsPreparar && itemsPreparar.length > 0) {\n      dadosInput = itemsPreparar[0].json;\n    }\n  } catch (e2) {\n    console.log('Aviso: Não foi possível buscar dados do nó 1.6');\n  }\n}\n\n// Resposta da IA (nó anterior - 1.7)\nconst respostaIA = $input.first().json;\n\n// Dados esperados do cliente real\nconst nomeLeadEsperado = dadosInput.nome_lead || dadosInput.name || dadosInput.contactName || '';\nconst telefoneEsperado = dadosInput.telefone_lead || dadosInput.phone || '';\nconst textoTranscricao = dadosInput.texto_transcricao || dadosInput.transcription || '';\n\n// Output da IA\nlet outputText = respostaIA.output || respostaIA.text || respostaIA.message || '';\n\n// Se output for objeto, converter para string\nif (typeof outputText === 'object') {\n  outputText = JSON.stringify(outputText);\n}\n\n// ========== LISTA DE CLIENTES CONHECIDOS (ANTI-ALUCINAÇÃO) ==========\n// Nomes que a IA NÃO deveria inventar para outros clientes\n// IMPORTANTE: Adicionar novos nomes conforme detectar alucinações\nconst CLIENTES_CONHECIDOS = [\n  'Dra. Eline Lobo',\n  'Eline Lobo',\n  'Dra Eline',\n  'Clínica da Dra. Eline',\n  'Clínica Eline Lobo',\n  'Dr. João Silva',\n  'João Silva',\n  'Clínica Premium',\n  'Dra. Maria',\n  'Dr. Carlos',\n  'Clínica Exemplo',\n  'Dr. Exemplo',\n  'Clínica Modelo',\n  'Dra. Ana Paula',\n  'Dr. Roberto',\n  'Clínica Saúde Total',\n  'Instituto Beleza',\n  'Centro Médico ABC',\n  // Adicionar mais conforme detectar novas alucinações\n];\n\n// ========== FUNÇÕES AUXILIARES ==========\n\nfunction extrairCampoJSON(texto, campo) {\n  try {\n    // Tentar múltiplos padrões de regex\n    const patterns = [\n      new RegExp(`\"${campo}\"\\\\s*:\\\\s*\"([^\"]+)\"`, 'i'),\n      new RegExp(`'${campo}'\\\\s*:\\\\s*'([^']+)'`, 'i'),\n      new RegExp(`${campo}\\\\s*:\\\\s*\"([^\"]+)\"`, 'i'),\n    ];\n    \n    for (const regex of patterns) {\n      const match = texto.match(regex);\n      if (match) return match[1];\n    }\n    return null;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction substituirCampoJSON(texto, campo, novoValor) {\n  try {\n    // Escapar caracteres especiais no novo valor\n    const valorEscapado = novoValor.replace(/\"/g, '\\\\\"');\n    \n    // Tentar múltiplos padrões\n    const patterns = [\n      { regex: new RegExp(`(\"${campo}\"\\\\s*:\\\\s*)\"([^\"]+)\"`, 'gi'), replacement: `$1\"${valorEscapado}\"` },\n      { regex: new RegExp(`('${campo}'\\\\s*:\\\\s*)'([^']+)'`, 'gi'), replacement: `$1'${valorEscapado}'` },\n    ];\n    \n    let resultado = texto;\n    for (const p of patterns) {\n      resultado = resultado.replace(p.regex, p.replacement);\n    }\n    return resultado;\n  } catch (e) {\n    return texto;\n  }\n}\n\nfunction normalizarNome(nome) {\n  if (!nome) return '';\n  return nome.toLowerCase()\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // Remove acentos\n    .replace(/[^a-z0-9\\s]/g, '') // Remove caracteres especiais\n    .replace(/\\s+/g, ' ') // Normaliza espaços\n    .trim();\n}\n\nfunction calcularSimilaridade(str1, str2) {\n  const s1 = normalizarNome(str1);\n  const s2 = normalizarNome(str2);\n\n  if (!s1 || !s2) return 0;\n  if (s1 === s2) return 1;\n  if (s1.includes(s2) || s2.includes(s1)) return 0.8;\n\n  const palavras1 = s1.split(/\\s+/).filter(p => p.length > 2);\n  const palavras2 = s2.split(/\\s+/).filter(p => p.length > 2);\n\n  if (palavras1.length === 0 || palavras2.length === 0) return 0;\n\n  let comuns = 0;\n  for (const p1 of palavras1) {\n    if (palavras2.some(p2 => p2.includes(p1) || p1.includes(p2))) {\n      comuns++;\n    }\n  }\n\n  return comuns / Math.max(palavras1.length, palavras2.length);\n}\n\n// ========== VALIDAÇÃO PRINCIPAL ==========\n\nconst validacao = {\n  passou: true,\n  alertas: [],\n  correcoes: [],\n  alucinacao_detectada: false,\n  nome_ia: null,\n  nome_esperado: nomeLeadEsperado,\n  similaridade: 0,\n  timestamp: new Date().toISOString()\n};\n\n// 1. Extrair nome_negocio do output da IA\nconst nomeNegocioIA = extrairCampoJSON(outputText, 'nome_negocio');\nvalidacao.nome_ia = nomeNegocioIA;\n\nif (nomeNegocioIA) {\n\n  // 2. Verificar se é um nome de OUTRO cliente (alucinação clara)\n  for (const clienteConhecido of CLIENTES_CONHECIDOS) {\n    const nomeNormalizado = normalizarNome(nomeNegocioIA);\n    const clienteNormalizado = normalizarNome(clienteConhecido);\n\n    // Verificar se o nome gerado contém um cliente conhecido\n    if (nomeNormalizado.includes(clienteNormalizado) || clienteNormalizado.includes(nomeNormalizado)) {\n      // Verificar se não é realmente o cliente atual\n      const leadNormalizado = normalizarNome(nomeLeadEsperado);\n      \n      if (!leadNormalizado.includes(clienteNormalizado) && !clienteNormalizado.includes(leadNormalizado)) {\n        validacao.alucinacao_detectada = true;\n        validacao.passou = false;\n        validacao.alertas.push({\n          tipo: 'ALUCINACAO_CRITICA',\n          severidade: 'ALTA',\n          mensagem: `IA gerou \"${nomeNegocioIA}\" mas cliente real é \"${nomeLeadEsperado}\"`,\n          cliente_inventado: nomeNegocioIA,\n          cliente_real: nomeLeadEsperado,\n          cliente_detectado: clienteConhecido,\n          timestamp: new Date().toISOString()\n        });\n\n        // CORRIGIR automaticamente\n        outputText = substituirCampoJSON(outputText, 'nome_negocio', nomeLeadEsperado);\n        validacao.correcoes.push({\n          campo: 'nome_negocio',\n          valor_errado: nomeNegocioIA,\n          valor_corrigido: nomeLeadEsperado,\n          motivo: 'Alucinação detectada - nome de outro cliente conhecido'\n        });\n\n        break;\n      }\n    }\n  }\n\n  // 3. Verificar similaridade entre nome da IA e nome esperado\n  if (!validacao.alucinacao_detectada) {\n    validacao.similaridade = calcularSimilaridade(nomeNegocioIA, nomeLeadEsperado);\n\n    if (validacao.similaridade < 0.15) {\n      // Nomes muito diferentes - possível alucinação\n      validacao.alertas.push({\n        tipo: 'BAIXA_SIMILARIDADE',\n        severidade: 'MEDIA',\n        mensagem: `Nome da IA \"${nomeNegocioIA}\" tem similaridade ${(validacao.similaridade * 100).toFixed(1)}% com \"${nomeLeadEsperado}\"`,\n        similaridade: validacao.similaridade\n      });\n\n      // Verificar se nome da IA aparece na transcrição\n      if (textoTranscricao) {\n        const transcricaoNormalizada = normalizarNome(textoTranscricao);\n        const nomeParcial = normalizarNome(nomeNegocioIA).substring(0, 15);\n        const nomeNaTranscricao = transcricaoNormalizada.includes(nomeParcial);\n\n        if (!nomeNaTranscricao) {\n          validacao.alucinacao_detectada = true;\n          validacao.passou = false;\n          validacao.alertas.push({\n            tipo: 'NOME_NAO_NA_TRANSCRICAO',\n            severidade: 'ALTA',\n            mensagem: `\"${nomeNegocioIA}\" não aparece na transcrição - provável alucinação`,\n            acao: 'Corrigido automaticamente para nome do input'\n          });\n\n          // CORRIGIR automaticamente\n          outputText = substituirCampoJSON(outputText, 'nome_negocio', nomeLeadEsperado);\n          validacao.correcoes.push({\n            campo: 'nome_negocio',\n            valor_errado: nomeNegocioIA,\n            valor_corrigido: nomeLeadEsperado,\n            motivo: 'Nome não encontrado na transcrição'\n          });\n        }\n      }\n    }\n  }\n} else if (nomeLeadEsperado) {\n  // Nome não encontrado no output - adicionar alerta\n  validacao.alertas.push({\n    tipo: 'CAMPO_NAO_ENCONTRADO',\n    severidade: 'BAIXA',\n    mensagem: 'Campo nome_negocio não encontrado no output da IA',\n    sugestao: 'Verificar se o formato do output está correto'\n  });\n}\n\n// 4. Se houve alucinação, verificar outros campos que podem estar contaminados\nif (validacao.alucinacao_detectada) {\n  const camposParaVerificar = ['nome_agente', 'empresa', 'clinica', 'negocio'];\n  \n  for (const campo of camposParaVerificar) {\n    const valorCampo = extrairCampoJSON(outputText, campo);\n    if (valorCampo) {\n      // Verificar se contém nome de cliente conhecido errado\n      for (const clienteConhecido of CLIENTES_CONHECIDOS) {\n        if (normalizarNome(valorCampo).includes(normalizarNome(clienteConhecido))) {\n          const leadNormalizado = normalizarNome(nomeLeadEsperado);\n          if (!leadNormalizado.includes(normalizarNome(clienteConhecido))) {\n            validacao.alertas.push({\n              tipo: 'CONTAMINACAO_CAMPO',\n              severidade: 'MEDIA',\n              mensagem: `Campo \"${campo}\" também pode estar contaminado com \"${valorCampo}\"`,\n              campo: campo,\n              valor: valorCampo,\n              sugestao: 'Verificar manualmente se faz sentido para o cliente correto'\n            });\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\n// 5. Verificar nome_agente especificamente\nconst nomeAgente = extrairCampoJSON(outputText, 'nome_agente');\nif (nomeAgente && validacao.alucinacao_detectada) {\n  validacao.alertas.push({\n    tipo: 'VERIFICAR_MANUALMENTE',\n    severidade: 'BAIXA',\n    mensagem: `Após correção, verificar se nome_agente \"${nomeAgente}\" ainda faz sentido`,\n    campo: 'nome_agente',\n    valor: nomeAgente,\n    sugestao: 'O nome do agente pode ser mantido ou regenerado'\n  });\n}\n\n// ========== LOG PARA MONITORAMENTO ==========\nconsole.log('');\nconsole.log('╔══════════════════════════════════════════════════════════════╗');\nconsole.log('║         VALIDAÇÃO ANTI-ALUCINAÇÃO - NÓ 1.8                  ║');\nconsole.log('╠══════════════════════════════════════════════════════════════╣');\nconsole.log(`║ Timestamp: ${new Date().toISOString()}`);\nconsole.log(`║ Cliente esperado: \"${nomeLeadEsperado}\"`);\nconsole.log(`║ Nome gerado pela IA: \"${nomeNegocioIA || 'NÃO ENCONTRADO'}\"`);\nconsole.log(`║ Similaridade: ${(validacao.similaridade * 100).toFixed(1)}%`);\nconsole.log('╠══════════════════════════════════════════════════════════════╣');\n\nif (validacao.alucinacao_detectada) {\n  console.log('║ ⚠️  ALUCINAÇÃO DETECTADA E CORRIGIDA!                        ║');\n} else {\n  console.log('║ ✅ Nenhuma alucinação detectada                              ║');\n}\n\nconsole.log(`║ Correções aplicadas: ${validacao.correcoes.length}`);\nconsole.log(`║ Alertas gerados: ${validacao.alertas.length}`);\n\nif (validacao.alertas.length > 0) {\n  console.log('╠══════════════════════════════════════════════════════════════╣');\n  console.log('║ ALERTAS:');\n  validacao.alertas.forEach((a, i) => {\n    console.log(`║  ${i + 1}. [${a.tipo}] ${a.mensagem.substring(0, 50)}...`);\n  });\n}\n\nif (validacao.correcoes.length > 0) {\n  console.log('╠══════════════════════════════════════════════════════════════╣');\n  console.log('║ CORREÇÕES:');\n  validacao.correcoes.forEach((c, i) => {\n    console.log(`║  ${i + 1}. ${c.campo}: \"${c.valor_errado.substring(0, 20)}...\" → \"${c.valor_corrigido.substring(0, 20)}...\"`);\n  });\n}\n\nconsole.log('╚══════════════════════════════════════════════════════════════╝');\nconsole.log('');\n\n// ========== RETORNO ==========\nreturn [{\n  json: {\n    // Manter todos os dados originais da resposta da IA\n    ...respostaIA,\n    // Substituir o output pelo corrigido (se houve correção)\n    output: outputText,\n    // Metadados da validação\n    _validacao_alucinacao: validacao,\n    _dados_input_original: {\n      nome_lead: nomeLeadEsperado,\n      telefone: telefoneEsperado,\n      tinha_transcricao: textoTranscricao.length > 0\n    },\n    _processado_em: new Date().toISOString(),\n    _versao_validador: '1.0.0'\n  }\n}];"
      },
      "id": "node-1-8-validar-alucinacao",
      "name": "1.8 Validar Alucinação",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 300],
      "notesInFlow": true,
      "notes": "ANTI-ALUCINAÇÃO: Detecta se a IA gerou dados de outro cliente e corrige automaticamente.\n\nClientes conhecidos na lista serão detectados.\nAdicione novos nomes conforme identificar alucinações."
    }
  ],
  "connections": {},
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  }
}
