import{_ as e,c as s,o as n,ag as o}from"./chunks/framework.dvv-DFtf.js";const g=JSON.parse('{"title":"Metodologia de Sub-Agentes","description":"","frontmatter":{},"headers":[],"relativePath":"arquitetura/cold-call-bot/metodologia.md","filePath":"arquitetura/cold-call-bot/metodologia.md"}'),l={name:"arquitetura/cold-call-bot/metodologia.md"};function i(t,a,r,p,d,c){return n(),s("div",null,[...a[0]||(a[0]=[o(`<h1 id="metodologia-de-sub-agentes" tabindex="-1">Metodologia de Sub-Agentes <a class="header-anchor" href="#metodologia-de-sub-agentes" aria-label="Permalink to &quot;Metodologia de Sub-Agentes&quot;">​</a></h1><h2 id="o-padrao" tabindex="-1">O Padrão <a class="header-anchor" href="#o-padrao" aria-label="Permalink to &quot;O Padrão&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. DIAGNOSTICAR (5 min)</span></span>
<span class="line"><span>   curl/grep direto nas APIs e código</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>2. DECOMPOR</span></span>
<span class="line"><span>   Identificar tarefas paralelas vs seriais</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>3. SPAWNAR com contexto PRECISO</span></span>
<span class="line"><span>   Cada agente: arquivos, schemas, APIs, design system</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>4. INTEGRAR</span></span>
<span class="line"><span>   Wire imports, TypeScript check, commit + push</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>5. VALIDAR</span></span>
<span class="line"><span>   curl endpoints, feedback visual do usuário</span></span></code></pre></div><h2 id="quando-spawnar-paralelo" tabindex="-1">Quando Spawnar Paralelo <a class="header-anchor" href="#quando-spawnar-paralelo" aria-label="Permalink to &quot;Quando Spawnar Paralelo&quot;">​</a></h2><ul><li>Tasks independentes (hook + componentes)</li><li>Research com ângulos diferentes (3 pesquisadores)</li><li>Backend + Frontend + DB simultâneo</li></ul><h2 id="quando-fazer-serial" tabindex="-1">Quando Fazer Serial <a class="header-anchor" href="#quando-fazer-serial" aria-label="Permalink to &quot;Quando Fazer Serial&quot;">​</a></h2><ul><li>Task B depende do output de Task A</li><li>Integração final (sempre manual)</li></ul><h2 id="_6-regras" tabindex="-1">6 Regras <a class="header-anchor" href="#_6-regras" aria-label="Permalink to &quot;6 Regras&quot;">​</a></h2><ol><li><strong>Contrato antes de spawnar</strong> — Defina interfaces/props antes</li><li><strong>Diagnóstico antes de delegar</strong> — 5min de curl vale 30min de agente</li><li><strong>Research triangulado</strong> — 3 ângulos &gt; 1 genérico</li><li><strong>Dica direcional</strong> — Se suspeita da causa, diga pro agente</li><li><strong>Tag antes de deploy</strong> — git tag pra rollback</li><li><strong>Error state sempre visível</strong> — Nunca retornar null silencioso</li></ol>`,9)])])}const h=e(l,[["render",i]]);export{g as __pageData,h as default};
