{"updatedAt":"2025-12-17T04:56:40.338Z","createdAt":"2025-11-30T21:27:37.040Z","id":"UZSQ0ovulSKyfbfL","name":"[TOOL] Salvar MovimentaÃ§Ã£o Financeira","description":null,"active":true,"isArchived":false,"nodes":[{"parameters":{"operation":"executeQuery","query":"INSERT INTO fin_movimentacoes (\n  tipo,\n  descricao,\n  valor_previsto,\n  valor_realizado,\n  data_vencimento,\n  data_realizado,\n  quitado,\n  tipo_entidade,\n  categoria_id,\n  cliente_fornecedor_id,\n  observacao\n)\nVALUES (\n  '{{ $json.tipo }}',\n  '{{ $json.descricao.replace(/'/g, \"''\") }}',\n  {{ $json.valor_previsto }},\n  {{ $json.valor_realizado || $json.valor_previsto || 'NULL' }},\n  ('{{ $json.data_vencimento }}T12:00:00'::timestamp AT TIME ZONE 'America/Sao_Paulo')::date,\n  {{ $json.data_realizado ? \"('\" + $json.data_realizado + \"T12:00:00'::timestamp AT TIME ZONE 'America/Sao_Paulo')::date\" : 'NULL' }},\n  {{ $json.quitado || false }},\n  '{{ $json.tipo_entidade || 'pj' }}',\n  {{ $json.categoria_id ? \"'\" + $json.categoria_id + \"'::uuid\" : 'NULL' }},\n  {{ $json.cliente_fornecedor_id ? \"'\" + $json.cliente_fornecedor_id + \"'::uuid\" : 'NULL' }},\n  {{ $json.observacao ? \"'\" + $json.observacao.replace(/'/g, \"''\") + \"'\" : 'NULL' }}\n)\nRETURNING *;","options":{"queryReplacement":"='{{ $json.data_vencimento }}'::date,"}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[432,-80],"id":"f79f387d-294e-4270-a670-889976342fe1","name":"Insert MovimentaÃ§Ã£o","credentials":{"postgres":{"id":"w2mBaRwhZ3tM4FUw","name":"Postgres Marcos Daniels."}}},{"parameters":{"jsCode":"const mov = $input.item.json;\n\nconst valorFormatado = new Intl.NumberFormat('pt-BR', {\n  style: 'currency',\n  currency: 'BRL'\n}).format(mov.valor_previsto || 0);\n\n// Trata a data corretamente\nlet dataFormatada = 'Data nÃ£o informada';\n\nif (mov.data_vencimento) {\n  // Pega sÃ³ a parte da data (YYYY-MM-DD) e ajusta timezone\n  const dataISO = mov.data_vencimento.split('T')[0];\n  const [ano, mes, dia] = dataISO.split('-');\n  \n  // Como o banco retorna em UTC (23:00 do dia anterior), soma 1 dia\n  const dataCorrigida = new Date(ano, mes - 1, parseInt(dia) + 1);\n  dataFormatada = dataCorrigida.toLocaleDateString('pt-BR');\n}\n\nreturn {\n  json: {\n    success: true,\n    message: 'MovimentaÃ§Ã£o salva com sucesso',\n    movimentacao_id: mov.id,\n    tipo: mov.tipo,\n    descricao: mov.descricao,\n    valor: valorFormatado,\n    data_vencimento: dataFormatada,\n    quitado: mov.quitado,\n    resumo: `${mov.tipo === 'receita' ? 'ðŸ’°' : 'ðŸ’³'} ${mov.tipo.toUpperCase()} de ${valorFormatado} salva para ${dataFormatada}`\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[656,-80],"id":"54d6cf09-6355-4e6c-b2ec-09e92f7c9bea","name":"Format Response"},{"parameters":{"workflowInputs":{"values":[{"name":"tipo"},{"name":"descricao"},{"name":"valor_previsto"},{"name":"data_vencimento"},{"name":"tipo_entidade"},{"name":"parcela_atual"},{"name":"total_parcelas"}]}},"type":"n8n-nodes-base.executeWorkflowTrigger","typeVersion":1.1,"position":[0,-80],"id":"b08eaedd-e150-43ff-b896-df9fdab3db35","name":"When Executed by Another Workflow"},{"parameters":{"jsCode":"const input = $input.first().json;\n\n// Padronizar descriÃ§Ã£o: primeira letra maiÃºscula de cada palavra\nconst descricaoPadronizada = (input.descricao || '')\n  .toLowerCase()\n  .split(' ')\n  .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1))\n  .join(' ');\n\n// Tratar data\nlet dataVencimento = input.data_vencimento;\n\nif (dataVencimento) {\n  if (dataVencimento.includes('/')) {\n    const partes = dataVencimento.split('/');\n    if (partes.length === 3) {\n      dataVencimento = `${partes[2]}-${partes[1].padStart(2, '0')}-${partes[0].padStart(2, '0')}`;\n    }\n  }\n  \n  const testeData = new Date(dataVencimento + 'T12:00:00');\n  if (isNaN(testeData.getTime())) {\n    dataVencimento = new Date().toISOString().split('T')[0];\n  }\n} else {\n  dataVencimento = new Date().toISOString().split('T')[0];\n}\n\n// Tratar valor\nlet valorPrevisto = input.valor_previsto;\n\nif (typeof valorPrevisto === 'string') {\n  valorPrevisto = valorPrevisto.replace(/[R$\\s]/g, '').trim();\n  \n  const temVirgula = valorPrevisto.includes(',');\n  const temPonto = valorPrevisto.includes('.');\n  \n  if (temVirgula && temPonto) {\n    if (valorPrevisto.lastIndexOf(',') > valorPrevisto.lastIndexOf('.')) {\n      valorPrevisto = valorPrevisto.replace(/\\./g, '').replace(',', '.');\n    } else {\n      valorPrevisto = valorPrevisto.replace(/,/g, '');\n    }\n  } else if (temVirgula) {\n    valorPrevisto = valorPrevisto.replace(',', '.');\n  }\n}\n\nvalorPrevisto = parseFloat(valorPrevisto) || 0;\n\n// ============================================================\n// LÃ“GICA DE PARCELAS FUTURAS\n// ============================================================\nconst parcelaAtual = parseInt(input.parcela_atual) || 0;\nconst totalParcelas = parseInt(input.total_parcelas) || 0;\n\n// Se tem info de parcela e nÃ£o Ã© a Ãºltima\nif (parcelaAtual > 0 && totalParcelas > 0 && parcelaAtual < totalParcelas) {\n  const parcelasFaltantes = totalParcelas - parcelaAtual;\n  const resultados = [];\n  \n  // Criar cada parcela futura\n  for (let i = 1; i <= parcelasFaltantes; i++) {\n    const proximaParcela = parcelaAtual + i;\n    \n    // Calcular data: adiciona i meses Ã  data base\n    const dataBase = new Date(dataVencimento + 'T12:00:00');\n    dataBase.setMonth(dataBase.getMonth() + i);\n    const dataFutura = dataBase.toISOString().split('T')[0];\n    \n    resultados.push({\n      json: {\n        ...input,\n        descricao: `${descricaoPadronizada} (${proximaParcela}/${totalParcelas})`,\n        data_vencimento: dataFutura,\n        valor_previsto: valorPrevisto,\n        tipo_entidade: (input.tipo_entidade || 'pj').toLowerCase(),\n        parcela_info: `${proximaParcela}/${totalParcelas}`,\n        is_parcela_futura: true\n      }\n    });\n  }\n  \n  return resultados;\n}\n\n// Caso normal (sem parcelas ou parcela Ãºnica)\nreturn {\n  json: {\n    ...input,\n    descricao: descricaoPadronizada,\n    data_vencimento: dataVencimento,\n    valor_previsto: valorPrevisto,\n    tipo_entidade: (input.tipo_entidade || 'pj').toLowerCase(),\n    is_parcela_futura: false\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[208,-80],"id":"3762e5c2-7875-48a9-896c-c58dd05c1440","name":"Code in JavaScript"}],"connections":{"Insert MovimentaÃ§Ã£o":{"main":[[{"node":"Format Response","type":"main","index":0}]]},"When Executed by Another Workflow":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Insert MovimentaÃ§Ã£o","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"f0821afd-bb6b-440a-88ce-76de9562e2f1","activeVersionId":"f0821afd-bb6b-440a-88ce-76de9562e2f1","versionCounter":14,"triggerCount":0,"shared":[{"updatedAt":"2025-11-30T21:27:37.064Z","createdAt":"2025-11-30T21:27:37.064Z","role":"workflow:owner","workflowId":"UZSQ0ovulSKyfbfL","projectId":"VAjodPr5Fy7WALLy","project":{"updatedAt":"2025-06-18T03:44:57.988Z","createdAt":"2025-06-18T03:36:54.736Z","id":"VAjodPr5Fy7WALLy","name":"Alan Jones Rios <alan@mentorfy.io>","type":"personal","icon":null,"description":null,"projectRelations":[{"updatedAt":"2025-06-18T03:36:54.737Z","createdAt":"2025-06-18T03:36:54.737Z","userId":"c236702a-fb1c-471c-b22c-6b898a17bcb1","projectId":"VAjodPr5Fy7WALLy","user":{"updatedAt":"2026-01-11T10:10:00.323Z","createdAt":"2025-06-18T03:36:53.786Z","id":"c236702a-fb1c-471c-b22c-6b898a17bcb1","email":"alan@mentorfy.io","firstName":"Alan Jones","lastName":"Rios","personalizationAnswers":{"version":"v4","personalization_survey_submitted_at":"2025-06-18T03:45:05.123Z","personalization_survey_n8n_version":"1.98.1"},"settings":{"userActivated":true,"easyAIWorkflowOnboarded":true,"firstSuccessfulWorkflowId":"ccHBfcfeKrXwUhIA","userActivatedAt":1750223854201,"npsSurvey":{"waitingForResponse":true,"ignoredCount":2,"lastShownAt":1768126200157},"dismissedCallouts":{"aiAgentStarterCallout":true,"ragStarterCallout":true}},"disabled":false,"mfaEnabled":false,"lastActiveAt":"2026-01-11","isPending":false}}]}}],"tags":[],"activeVersion":{"updatedAt":"2025-12-15T10:53:02.673Z","createdAt":"2025-12-15T10:53:02.673Z","versionId":"f0821afd-bb6b-440a-88ce-76de9562e2f1","workflowId":"UZSQ0ovulSKyfbfL","nodes":[{"parameters":{"operation":"executeQuery","query":"INSERT INTO fin_movimentacoes (\n  tipo,\n  descricao,\n  valor_previsto,\n  valor_realizado,\n  data_vencimento,\n  data_realizado,\n  quitado,\n  tipo_entidade,\n  categoria_id,\n  cliente_fornecedor_id,\n  observacao\n)\nVALUES (\n  '{{ $json.tipo }}',\n  '{{ $json.descricao.replace(/'/g, \"''\") }}',\n  {{ $json.valor_previsto }},\n  {{ $json.valor_realizado || $json.valor_previsto || 'NULL' }},\n  ('{{ $json.data_vencimento }}T12:00:00'::timestamp AT TIME ZONE 'America/Sao_Paulo')::date,\n  {{ $json.data_realizado ? \"('\" + $json.data_realizado + \"T12:00:00'::timestamp AT TIME ZONE 'America/Sao_Paulo')::date\" : 'NULL' }},\n  {{ $json.quitado || false }},\n  '{{ $json.tipo_entidade || 'pj' }}',\n  {{ $json.categoria_id ? \"'\" + $json.categoria_id + \"'::uuid\" : 'NULL' }},\n  {{ $json.cliente_fornecedor_id ? \"'\" + $json.cliente_fornecedor_id + \"'::uuid\" : 'NULL' }},\n  {{ $json.observacao ? \"'\" + $json.observacao.replace(/'/g, \"''\") + \"'\" : 'NULL' }}\n)\nRETURNING *;","options":{"queryReplacement":"='{{ $json.data_vencimento }}'::date,"}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[432,-80],"id":"f79f387d-294e-4270-a670-889976342fe1","name":"Insert MovimentaÃ§Ã£o","credentials":{"postgres":{"id":"w2mBaRwhZ3tM4FUw","name":"Postgres Marcos Daniels."}}},{"parameters":{"jsCode":"const mov = $input.item.json;\n\nconst valorFormatado = new Intl.NumberFormat('pt-BR', {\n  style: 'currency',\n  currency: 'BRL'\n}).format(mov.valor_previsto || 0);\n\n// Trata a data corretamente\nlet dataFormatada = 'Data nÃ£o informada';\n\nif (mov.data_vencimento) {\n  // Pega sÃ³ a parte da data (YYYY-MM-DD) e ajusta timezone\n  const dataISO = mov.data_vencimento.split('T')[0];\n  const [ano, mes, dia] = dataISO.split('-');\n  \n  // Como o banco retorna em UTC (23:00 do dia anterior), soma 1 dia\n  const dataCorrigida = new Date(ano, mes - 1, parseInt(dia) + 1);\n  dataFormatada = dataCorrigida.toLocaleDateString('pt-BR');\n}\n\nreturn {\n  json: {\n    success: true,\n    message: 'MovimentaÃ§Ã£o salva com sucesso',\n    movimentacao_id: mov.id,\n    tipo: mov.tipo,\n    descricao: mov.descricao,\n    valor: valorFormatado,\n    data_vencimento: dataFormatada,\n    quitado: mov.quitado,\n    resumo: `${mov.tipo === 'receita' ? 'ðŸ’°' : 'ðŸ’³'} ${mov.tipo.toUpperCase()} de ${valorFormatado} salva para ${dataFormatada}`\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[656,-80],"id":"54d6cf09-6355-4e6c-b2ec-09e92f7c9bea","name":"Format Response"},{"parameters":{"workflowInputs":{"values":[{"name":"tipo"},{"name":"descricao"},{"name":"valor_previsto"},{"name":"data_vencimento"},{"name":"tipo_entidade"},{"name":"parcela_atual"},{"name":"total_parcelas"}]}},"type":"n8n-nodes-base.executeWorkflowTrigger","typeVersion":1.1,"position":[0,-80],"id":"b08eaedd-e150-43ff-b896-df9fdab3db35","name":"When Executed by Another Workflow"},{"parameters":{"jsCode":"const input = $input.first().json;\n\n// Padronizar descriÃ§Ã£o: primeira letra maiÃºscula de cada palavra\nconst descricaoPadronizada = (input.descricao || '')\n  .toLowerCase()\n  .split(' ')\n  .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1))\n  .join(' ');\n\n// Tratar data\nlet dataVencimento = input.data_vencimento;\n\nif (dataVencimento) {\n  if (dataVencimento.includes('/')) {\n    const partes = dataVencimento.split('/');\n    if (partes.length === 3) {\n      dataVencimento = `${partes[2]}-${partes[1].padStart(2, '0')}-${partes[0].padStart(2, '0')}`;\n    }\n  }\n  \n  const testeData = new Date(dataVencimento + 'T12:00:00');\n  if (isNaN(testeData.getTime())) {\n    dataVencimento = new Date().toISOString().split('T')[0];\n  }\n} else {\n  dataVencimento = new Date().toISOString().split('T')[0];\n}\n\n// Tratar valor\nlet valorPrevisto = input.valor_previsto;\n\nif (typeof valorPrevisto === 'string') {\n  valorPrevisto = valorPrevisto.replace(/[R$\\s]/g, '').trim();\n  \n  const temVirgula = valorPrevisto.includes(',');\n  const temPonto = valorPrevisto.includes('.');\n  \n  if (temVirgula && temPonto) {\n    if (valorPrevisto.lastIndexOf(',') > valorPrevisto.lastIndexOf('.')) {\n      valorPrevisto = valorPrevisto.replace(/\\./g, '').replace(',', '.');\n    } else {\n      valorPrevisto = valorPrevisto.replace(/,/g, '');\n    }\n  } else if (temVirgula) {\n    valorPrevisto = valorPrevisto.replace(',', '.');\n  }\n}\n\nvalorPrevisto = parseFloat(valorPrevisto) || 0;\n\n// ============================================================\n// LÃ“GICA DE PARCELAS FUTURAS\n// ============================================================\nconst parcelaAtual = parseInt(input.parcela_atual) || 0;\nconst totalParcelas = parseInt(input.total_parcelas) || 0;\n\n// Se tem info de parcela e nÃ£o Ã© a Ãºltima\nif (parcelaAtual > 0 && totalParcelas > 0 && parcelaAtual < totalParcelas) {\n  const parcelasFaltantes = totalParcelas - parcelaAtual;\n  const resultados = [];\n  \n  // Criar cada parcela futura\n  for (let i = 1; i <= parcelasFaltantes; i++) {\n    const proximaParcela = parcelaAtual + i;\n    \n    // Calcular data: adiciona i meses Ã  data base\n    const dataBase = new Date(dataVencimento + 'T12:00:00');\n    dataBase.setMonth(dataBase.getMonth() + i);\n    const dataFutura = dataBase.toISOString().split('T')[0];\n    \n    resultados.push({\n      json: {\n        ...input,\n        descricao: `${descricaoPadronizada} (${proximaParcela}/${totalParcelas})`,\n        data_vencimento: dataFutura,\n        valor_previsto: valorPrevisto,\n        tipo_entidade: (input.tipo_entidade || 'pj').toLowerCase(),\n        parcela_info: `${proximaParcela}/${totalParcelas}`,\n        is_parcela_futura: true\n      }\n    });\n  }\n  \n  return resultados;\n}\n\n// Caso normal (sem parcelas ou parcela Ãºnica)\nreturn {\n  json: {\n    ...input,\n    descricao: descricaoPadronizada,\n    data_vencimento: dataVencimento,\n    valor_previsto: valorPrevisto,\n    tipo_entidade: (input.tipo_entidade || 'pj').toLowerCase(),\n    is_parcela_futura: false\n  }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[208,-80],"id":"3762e5c2-7875-48a9-896c-c58dd05c1440","name":"Code in JavaScript"}],"connections":{"Insert MovimentaÃ§Ã£o":{"main":[[{"node":"Format Response","type":"main","index":0}]]},"When Executed by Another Workflow":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Insert MovimentaÃ§Ã£o","type":"main","index":0}]]}},"authors":"Alan Jones Rios","name":null,"description":null,"workflowPublishHistory":[{"createdAt":"2025-12-15T10:53:02.000Z","id":135,"workflowId":"UZSQ0ovulSKyfbfL","versionId":"f0821afd-bb6b-440a-88ce-76de9562e2f1","event":"activated","userId":null}]}}